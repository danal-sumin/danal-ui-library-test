import StyleDictionary from "style-dictionary";
import { register } from "@tokens-studio/sd-transforms";
import { Config, TransformedToken } from "style-dictionary/types";

register(StyleDictionary, {
  excludeParentKeys: false    // 중첩 키 최적화
});
console.log("Registered @tokens-studio/sd-transforms with vanilla-extract optimizations!");

// 토큰 소스를 전처리하여 참조 경로 수정
StyleDictionary.registerPreprocessor({
  name: 'tokens-studio/resolve-references',
  preprocessor: (dictionary) => {
    // tokens 객체를 플랫폼화하여 참조 문제 해결
    if (dictionary.tokens) {
      const flatTokens = dictionary.tokens;
      // tokens 키를 제거하고 내용을 최상위로 이동
      Object.assign(dictionary, flatTokens);
      delete dictionary.tokens;
    }
    return dictionary;
  }
});


// 토큰 이름을 정리하는 함수 (vanilla-extract에 최적화)
function sanitizeTokenName(name: string): string {
  return name
    .replace(/\x08/g, '')     // backspace 문자(\b) 완전 제거
    .replace(/\s+/g, '_')     // 공백을 언더스코어로
    .replace(/-/g, '_')       // 하이픈을 언더스코어로
    .replace(/[^\w_]/g, '_')  // 문자, 숫자, 언더스코어만 허용
    .replace(/_+/g, '_')      // 연속된 언더스코어를 하나로
    .replace(/^_+|_+$/g, '')  // 시작/끝 언더스코어 제거
    .toLowerCase();           // 소문자로 변환 (일관성을 위해)
}



// Name Transform 등록 (충돌 방지)
StyleDictionary.registerTransform({
  name: 'name/path-kebab',
  type: 'name',
  transform: function(token: TransformedToken) {
    // 전체 경로를 포함하여 고유한 이름 생성
    return token.path
      .map((segment: string) => sanitizeTokenName(segment))
      .join('_');
  }
});

// Vanilla Extract 포맷 등록 (최적화된 버전)
StyleDictionary.registerFormat({
  name: "css/vanilla-extract",
  format: async ({ dictionary, options }) => {
    const { selector = ":root" } = options || {};

    function buildTokenTree(tokens: any[]): any {
      const tree: any = {};

      tokens.forEach((token: any) => {
        let current = tree;
        // 전체 경로를 보존하여 충돌 완전 방지
        const sanitizedPath = token.path.map((segment: string) => sanitizeTokenName(segment));

        // 네임스페이스를 완전히 보존하여 중첩 구조 유지
        for (let i = 0; i < sanitizedPath.length - 1; i++) {
          const key = sanitizedPath[i];
          if (!current[key]) {
            current[key] = {};
          }
          current = current[key];
        }

        const lastKey = sanitizedPath[sanitizedPath.length - 1];
        current[lastKey] = token.$value || token.value;
      });

      return tree;
    }

    const tokenTree = buildTokenTree(dictionary.allTokens);

    // 토큰 타입 추출 (개선된 버전)
    function generateTokenTypes(obj: any, path: string[] = []): string[] {
      let types: string[] = [];
      
      Object.keys(obj).forEach(key => {
        const currentPath = [...path, key];
        if (typeof obj[key] === 'object' && obj[key] !== null && Object.keys(obj[key]).length > 0) {
          types = types.concat(generateTokenTypes(obj[key], currentPath));
        } else if (typeof obj[key] === 'string') {
          types.push(`  '${currentPath.join('.')}'?: string;`);
        }
      });
      
      return types;
    }

    const typeDefinitions = generateTokenTypes(tokenTree);

    return `/**
 * Design Tokens
 * 자동 생성된 파일 - 수동으로 수정하지 마세요
 * 
 * @generated by Style Dictionary
 * @see https://github.com/amzn/style-dictionary
 */

import { createGlobalTheme } from '@vanilla-extract/css';

export const tokens = createGlobalTheme('${selector}', ${JSON.stringify(tokenTree, null, 2)});

`;
  },
});





const config: Config = {
  source: ["design-tokens.json"],
  preprocessors: ['tokens-studio/resolve-references'],
  platforms: {
    vanillaExtract: {
      transforms: [
        'name/path-kebab',    // 충돌 방지를 위한 이름 변환
        'ts/resolveMath',
        'ts/size/px', 
        'ts/color/modifiers',
      ],
      buildPath: "src/styles/",
      files: [
        {
          destination: "tokens.css.ts",
          format: "css/vanilla-extract",
          options: {
            selector: ":root"
          }
        }
      ]
    }
  },
  log: {
    verbosity: "verbose", 
  }
}

const sd = new StyleDictionary(config);

async function buildTokens() {
  try{
    await sd.buildAllPlatforms();
    console.log('✅ Tokens built successfully!');
  }catch(error){
    console.error('❌ Error building tokens:', error);
    process.exit(1);
  }
}

buildTokens();